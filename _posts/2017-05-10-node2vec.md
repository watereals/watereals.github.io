---
layout: post
title: node2vec
mathjax: true
---

# node2vec

博客: http://geek.csdn.net/news/detail/200138

论文: https://arxiv.org/abs/1607.00653

GitHub: Python: https://github.com/aditya-grover/node2vec

GitHub: C++:    https://github.com/snap-stanford/snap/tree/master/examples/node2vec

## node2vec 原理理解

思想：

1. 将遍历图得到路径(sequence of node)输入到word2vec中学习得到每个node的vector.
2. 其中，在遍历生成sequence of node时,不同于一般的DFS和BFS,采用随机游走的方式并对不同的neighbor节点设置不同的权重.
3. 使用alias_method来进行随机游走的采样

随机游走生成sequence of node的方法:

Initialize:

1. compute all start node transition probability by weight of edges

    $$NodeProb_{v_i,v_j} = \frac {weight(v_i,v_j) } { \sum_{v_j \in neighbor(v_i)} weight(v_i,v_j) }$$

2. Store $NodeProb(v_i)$的alias_method需要的参数

3. compute other nodes transition probability by weight of edges and p, q

    $$ \alpha(e_{ij}, v_k) = \left\{\begin{array}{ll}
        1,            & \text{if}\; v_k = v_i 
        \\ 1 / p,     & \text{if exist}\; e_{i,k} 
        \\ 1 / q,     & \text{otherwise}\;
        \end{array}\right. $$
    
    $$ w(e_{ij}, v_k) = w(v_j, v_k) / \alpha(e_{ij},v_k)$$

    $$EdgeProb(e_{ij},v_k) = \frac {w(e_{ij},v_k) } { \sum_{v_k \in neighbor(v_j)} w(e_{ij},v_k) }$$

4. Store $EdgeProb(e_{ij})$的alias_method需要的参数

Generate:

1. Shuffle nodes of graph.
2. for $v_i$ in nodes:
    + 2.1 add $v_i$ to $path$
    + 2.2 sample $v_j$ by alias_method with pememater $NodePorb(v_i)$
    + 2.3 add $v_j$ to $path$, and set $lasti,lastj$ = $v_i,v_j$
    + 2.4 $while(length < len)$
        + 2.4.1   sample ${v_k}$ by alias_method with pememater $EdgeProb(e_{lasti,lastj})$
        + 2.4.2 $lasti,lastj$ = $lastj, v_k$
        + 2.4.3 add $v_k$ to $path$
    + 2.5 save $path$

